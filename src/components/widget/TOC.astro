---
import type { MarkdownHeading } from "astro";
import { siteConfig } from "../../config";
import { url } from "../../utils/url-utils";

interface Props {
	class?: string;
	headings: MarkdownHeading[];
}

let { headings = [] } = Astro.props;

let minDepth = 10;
for (const heading of headings) {
	minDepth = Math.min(minDepth, heading.depth);
}

const className = Astro.props.class;
// 修复路由判断逻辑，确保在文章页面能正确显示TOC
const isPostsRoute =
	Astro.url.pathname.includes("/posts/") || headings.length > 0;

const removeTailingHash = (text: string) => {
	let lastIndexOfHash = text.lastIndexOf("#");
	if (lastIndexOfHash !== text.length - 1) {
		return text;
	}

	return text.substring(0, lastIndexOfHash);
};

let heading1Count = 1;

const maxLevel = siteConfig.toc.depth;
---
<table-of-contents class:list={[className, "group"]} id="toc">
    <!-- TOC内容将由JavaScript动态生成 -->
</table-of-contents>

<script>
class TableOfContents extends HTMLElement {
    tocEl: HTMLElement | null = null;
    visibleClass = "visible";
    observer: IntersectionObserver | null = null;
    scrollHandler: (() => void) | null = null;
    anchorNavTarget: HTMLElement | null = null;
    headingIdxMap = new Map<string, number>();
    headings: HTMLElement[] = [];
    sections: HTMLElement[] = [];
    tocEntries: HTMLAnchorElement[] = [];
    active: boolean[] = [];
    activeIndicator: HTMLElement | null = null;
    
    // 性能优化：添加节流控制
    private updateThrottleId: number | null = null;
    private isUpdating = false;

    constructor() {
        super();
        this.observer = new IntersectionObserver(
            this.markVisibleSection, { threshold: 0 }
        );
    };

    markVisibleSection = (entries: IntersectionObserverEntry[]) => {
        
        entries.forEach((entry) => {
            const id = entry.target.querySelector('h1, h2, h3, h4, h5, h6')?.id;
            if (!id) return;
            
            const idx = this.headingIdxMap.get(id);
            if (idx !== undefined) {
                this.active[idx] = entry.isIntersecting;
            }
        });
        
        // 立即更新光标位置
        this.update();
    };

    // 统一的光标定位逻辑
    toggleActiveHeading = () => {
        try {
            // 安全检查基本条件
            if (!this.headings.length || !this.sections.length || !this.tocEntries.length) {
                return;
            }

            // 清除所有活跃状态
            this.tocEntries.forEach(entry => {
                if (entry) entry.classList.remove("active");
            });

            let activeIndex = -1;
            const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
            const windowHeight = window.innerHeight;
            const navOffset = 80; // 导航栏高度

            // 检查是否在页面底部
            const isAtBottom = (windowHeight + scrollTop) >= (document.documentElement.scrollHeight - 50);
            
            if (isAtBottom && this.headings.length > 0) {
                activeIndex = this.headings.length - 1;
            } else {
                // 找到当前最合适的标题
                for (let i = 0; i < this.headings.length; i++) {
                    const heading = this.headings[i];
                    if (!heading || !document.contains(heading)) continue;

                    const rect = this.getSafeRect(heading);
                    if (!rect) continue;

                    // 如果标题在视口上方不远处，或者在视口顶部附近
                    if (rect.top <= navOffset + 50) {
                        activeIndex = i;
                    } else {
                        // 如果标题在视口下方，停止查找
                        break;
                    }
                }
            }

            // 激活选中的标题并更新光标
             if (activeIndex >= 0 && activeIndex < this.tocEntries.length) {
                 const activeEntry = this.tocEntries[activeIndex];
                 if (activeEntry) {
                     activeEntry.classList.add("active");
                     this.updateActiveIndicator(activeIndex);
                 }
             } else {
                 // 隐藏光标
                 this.updateActiveIndicator(-1);
             }

        } catch (error) {
        }
    };

    // 更新活跃指示器位置（简化版本）
    updateActiveIndicator = (activeIndex: number) => {
        if (!this.activeIndicator) {
            this.activeIndicator = document.getElementById("active-indicator");
        }
        
        if (activeIndex < 0 || activeIndex >= this.tocEntries.length || !this.activeIndicator) {
            // 隐藏光标
            if (this.activeIndicator) {
                this.activeIndicator.style.opacity = "0";
            }
            return;
        }

        try {
            const activeEntry = this.tocEntries[activeIndex];
            if (!activeEntry || !document.contains(activeEntry) || !this.tocEl) {
                return;
            }

            const entryRect = this.getSafeRect(activeEntry);
            const tocRect = this.getSafeRect(this.tocEl);
            
            if (entryRect && tocRect) {
                const relativeTop = entryRect.top - tocRect.top + (this.tocEl.scrollTop || 0);
                this.activeIndicator.style.top = `${relativeTop}px`;
                this.activeIndicator.style.height = `${entryRect.height}px`;
                this.activeIndicator.style.opacity = "1";
            }
        } catch (error) {
        }
    };

    scrollToActiveHeading = () => {
        // If the TOC widget can accommodate both the topmost
        // and bottommost items, scroll to the topmost item. 
        // Otherwise, scroll to the bottommost one.

        if (this.anchorNavTarget || !this.tocEl) return;
        const activeHeading =
            document.querySelectorAll<HTMLDivElement>(`#toc .${this.visibleClass}`);
        if (!activeHeading.length) return;

        const topmost = activeHeading[0];
        const bottommost = activeHeading[activeHeading.length - 1];
        const tocHeight = this.tocEl.clientHeight;

        let top;
        if (bottommost.getBoundingClientRect().bottom -
            topmost.getBoundingClientRect().top < 0.9 * tocHeight)
            top = topmost.offsetTop - 32;
        else
            top = bottommost.offsetTop - tocHeight * 0.8;

        this.tocEl.scrollTo({
            top,
            left: 0,
            behavior: "smooth",
        });
    };

    // 安全获取元素的边界矩形
    private getSafeRect(element: HTMLElement | null): DOMRect | null {
        try {
            if (!element || !document.contains(element)) {
                return null;
            }
            return element.getBoundingClientRect();
        } catch (error) {
            return null;
        }
    }

    // 安全检查元素是否在视口中
    private isElementInViewport(element: HTMLElement | null): boolean {
        if (!element) return false;
        
        const rect = this.getSafeRect(element);
        if (!rect) return false;
        
        const windowHeight = window.innerHeight || document.documentElement.clientHeight;
        const windowWidth = window.innerWidth || document.documentElement.clientWidth;
        
        return (
            rect.top >= 0 &&
            rect.left >= 0 &&
            rect.bottom <= windowHeight &&
            rect.right <= windowWidth
        );
    }
    private throttle(func: Function, delay: number): () => void {
        let timeoutId: ReturnType<typeof setTimeout> | null = null;
        let lastExecTime = 0;
        
        return () => {
            const currentTime = Date.now();
            
            if (currentTime - lastExecTime > delay) {
                func();
                lastExecTime = currentTime;
            } else {
                if (timeoutId) {
                    clearTimeout(timeoutId);
                }
                timeoutId = setTimeout(() => {
                    func();
                    lastExecTime = Date.now();
                }, delay - (currentTime - lastExecTime));
            }
        };
    }

    // 简化的更新函数
    update = () => {
        if (this.isUpdating) return;
        
        if (this.updateThrottleId) {
            cancelAnimationFrame(this.updateThrottleId);
        }
        
        this.updateThrottleId = requestAnimationFrame(() => {
            this.isUpdating = true;
            try {
                this.toggleActiveHeading();
                // 移除scrollToActiveHeading调用，避免光标乱飞
            } catch (error) {
            } finally {
                this.isUpdating = false;
                this.updateThrottleId = null;
            }
        });
    };

    fallback = () => {
        if (!this.sections.length) return;

        // 重置所有活动状态
        this.active.fill(false);

        for (let i = 0; i < this.sections.length; i++) {
            let offsetTop = this.sections[i].getBoundingClientRect().top;
            let offsetBottom = this.sections[i].getBoundingClientRect().bottom;

            if (this.isInRange(offsetTop, 0, window.innerHeight)
                || this.isInRange(offsetBottom, 0, window.innerHeight)
                || (offsetTop < 0 && offsetBottom > window.innerHeight)) {
                this.markActiveHeading(i);
            }
            else if (offsetTop > window.innerHeight) break;
        }
        
        // 如果没有任何标题在视口中，激活第一个标题
        if (!this.active.includes(true) && this.sections.length > 0) {
            this.markActiveHeading(0);
        }
    };

    markActiveHeading = (idx: number)=> {
        this.active[idx] = true;
    };

    handleAnchorClick = (event: Event) => {
        const anchor = event
            .composedPath()
            .find((element) => element instanceof HTMLAnchorElement) as HTMLAnchorElement;

        if (anchor && anchor.hash) {
            event.preventDefault(); // 阻止默认的锚点跳转
            
            const id = decodeURIComponent(anchor.hash.substring(1));
            const targetElement = document.getElementById(id);
            
            if (targetElement) {
                // 计算目标位置，与移动端保持一致
                const navbarHeight = 80; // 导航栏高度
                const targetTop = targetElement.getBoundingClientRect().top + window.pageYOffset - navbarHeight;
                
                // 使用与移动端相同的滚动方式
                window.scrollTo({
                    top: targetTop,
                    behavior: "smooth"
                });
            }
            
            const idx = this.headingIdxMap.get(id);
            if (idx !== undefined) {
                this.anchorNavTarget = this.headings[idx];
            } else {
                this.anchorNavTarget = null;
            }
        }
    };

    isInRange(value: number, min: number, max: number) {
        return min < value && value < max;
    }

    connectedCallback() {
        
        // 设置Swup监听器的函数
        const setupSwupListener = () => {
            if (typeof window !== 'undefined' && (window as any).swup) {
                (window as any).swup.hooks.on('content:replace', () => {
                    this.reinitialize();
                });
            } else {
                // 如果Swup还没有加载，监听其启用事件
                document.addEventListener('swup:enable', () => {
                    setupSwupListener();
                });
            }
        };
        
        // 立即尝试设置监听器
        setupSwupListener();
        
        // 延迟初始化，确保DOM完全加载
        setTimeout(() => {
            this.init();
        }, 200);
    }

    init() {
        
        // 重新生成TOC内容
        this.regenerateTOC();

        this.tocEl = this;

        this.tocEl.addEventListener("click", this.handleAnchorClick, {
            capture: true,
        });

        this.activeIndicator = document.getElementById("active-indicator");

        this.tocEntries = Array.from(
            this.querySelectorAll<HTMLAnchorElement>("a[href^='#']")
        );

        if (this.tocEntries.length === 0) {
            return;
        }

        this.sections = new Array(this.tocEntries.length);
        this.headings = new Array(this.tocEntries.length);
        for (let i = 0; i < this.tocEntries.length; i++) {
            const id = decodeURIComponent(this.tocEntries[i].hash?.substring(1));
            const heading = document.getElementById(id);
            const section = heading?.parentElement;
            if (heading instanceof HTMLElement && section instanceof HTMLElement) {
                this.headings[i] = heading;
                this.sections[i] = section;
                this.headingIdxMap.set(id, i);
            }
        }
        this.active = new Array(this.tocEntries.length).fill(false);

        // 初始化IntersectionObserver
        if (!this.observer) {
            this.observer = new IntersectionObserver(
                (entries) => {
                    this.markVisibleSection(entries);
                },
                {
                    rootMargin: "-60px 0px -60px 0px",
                    threshold: [0, 0.1, 0.5, 1.0],
                }
            );
        }

        this.sections.forEach((section) => {
            if (section && this.observer) this.observer.observe(section);
        });

        // 添加滚动监听器来处理底部检测
        const handleScroll = () => {
            // 直接调用更新，减少复杂性
            this.update();
        };
        
        // 移除之前的滚动监听器（如果存在）
        if (this.scrollHandler) {
            window.removeEventListener('scroll', this.scrollHandler);
        }
        
        // 添加新的滚动监听器，使用更长的节流间隔减少频繁更新
        const throttledHandler = this.throttle(handleScroll, 50); // 降低到20fps
        this.scrollHandler = throttledHandler;
        window.addEventListener('scroll', throttledHandler, { passive: true });

        // 初始化后立即更新一次光标位置
        setTimeout(() => {
            this.fallback();
            this.update();
        }, 100);

    };

    // 重新初始化方法，用于页面切换后的重新初始化
    reinitialize() {
        
        // 清理现有的观察器
        if (this.observer) {
            this.observer.disconnect();
            this.observer = null;
        }
        
        // 重新生成TOC内容
        this.regenerateTOC();
        
        // 重新初始化
        this.init();
    }

    regenerateTOC() {
        // 检查是否为文章页面
        const isPostPage = window.location.pathname.includes('/posts/') || 
                          document.querySelector('.custom-md, .markdown-content') !== null;
        
        if (!isPostPage) {
            // 如果不是文章页面，隐藏TOC
            this.innerHTML = '';
            this.style.display = 'none';
            return;
        } else {
            // 如果是文章页面，确保TOC可见
            this.style.display = '';
        }

        // 从当前页面重新获取标题
        const headings = Array.from(document.querySelectorAll('h1, h2, h3, h4, h5, h6'))
            .filter(h => h.id) // 只包含有id的标题
                .map(h => ({
                    depth: parseInt(h.tagName.substring(1)),
                    slug: h.id,
                    // 去除标题开头和结尾的 # 及空格
                    text: (h.textContent || '').replace(/^#+\s*/, '').replace(/#+\s*$/, '')
                }));
        
        // 如果没有标题，清空TOC但保持容器
        if (headings.length === 0) {
            this.innerHTML = '<div class="text-center py-4 text-black/50 dark:text-white/50 text-sm">当前页面没有目录</div>';
            return;
        }

        // 重新生成TOC HTML
        const minDepth = Math.min(...headings.map(h => h.depth));
        const maxLevel = 3; // siteConfig.toc.depth
        let heading1Count = 1;
        
        const tocHTML = headings
            .filter(heading => heading.depth < minDepth + maxLevel)
            .map(heading => {
                const depthClass = heading.depth === minDepth ? '' : 
                    heading.depth === minDepth + 1 ? 'ml-4' : 'ml-8';
                const badgeContent = heading.depth === minDepth ? (heading1Count++) :
                    heading.depth === minDepth + 1 ? '<div class="transition w-2 h-2 rounded-[0.1875rem] bg-[var(--toc-badge-bg)]"></div>' :
                    '<div class="transition w-1.5 h-1.5 rounded-sm bg-black/5 dark:bg-white/10"></div>';
                
                return `<a href="#${heading.slug}" class="px-2 flex gap-2 relative transition w-full min-h-9 rounded-xl hover:bg-[var(--toc-btn-hover)] active:bg-[var(--toc-btn-active)] py-2">
                    <div class="transition w-5 h-5 shrink-0 rounded-lg text-xs flex items-center justify-center font-bold ${depthClass} ${heading.depth === minDepth ? 'bg-[var(--toc-badge-bg)] text-[var(--btn-content)]' : ''}">
                        ${badgeContent}
                    </div>
                    <div class="transition text-sm ${heading.depth <= minDepth + 1 ? 'text-50' : 'text-30'}">${heading.text}</div>
                </a>`;
            }).join('');
        
        this.innerHTML = tocHTML + '<div id="active-indicator" style="opacity: 0" class="-z-10 absolute bg-[var(--toc-btn-hover)] left-0 right-0 rounded-xl transition-all group-hover:bg-transparent border-2 border-[var(--toc-btn-hover)] group-hover:border-[var(--toc-btn-active)] border-dashed"></div>';
    }

    disconnectedCallback() {
        if (this.observer) {
            this.sections.forEach((section) =>
                this.observer?.unobserve(section)
            );
            this.observer.disconnect();
        }
        
        if (this.scrollHandler) {
            window.removeEventListener('scroll', this.scrollHandler);
        }
        
        // 清理节流相关资源
        if (this.updateThrottleId) {
            cancelAnimationFrame(this.updateThrottleId);
            this.updateThrottleId = null;
        }
        
        this.tocEl?.removeEventListener("click", this.handleAnchorClick);
    };
}

if (!customElements.get("table-of-contents")) {
    customElements.define("table-of-contents", TableOfContents);
}
</script>